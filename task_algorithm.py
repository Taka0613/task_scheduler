# -*- coding: utf-8 -*-
"""CS 110 Assignment-Copy1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZBD11Xzghdts50JVtH_mt8tD-XT7rBHW

## High-level description of the algorithm

The input:
All the tasks that you want to do today with basic information.
The time that you start doing all your tasks.
Algorithm steps:
Divide tasks into tasks that have a non-fixed starting time and that have a fixed starting time.
For the “fixed starting time” tasks, sort them in the order of their starting time. The task that starts the earliest should come first, and the task that starts the latest should come last.
Next, we want to sort “non-fixed starting time” tasks. First, we identify tasks that precede tasks that start at a fixed time. For instance, doing preclass work is necessary for taking a class that starts at 6PM, so we say that doing preclass work has more priority than taking a class. Similarly, if you need to go to a cafe to do a preclass work, so we say that going to cafe has more priority than doing a preclass work. In this context, if a task has more priority than task B, it means that should be completed earlier than task B. If two tasks happen to have same priority based on this criteria, we decide which one to do first based on the happiness and future usefulness a task brings to you. For instance, eating lunch and going to a cafe might both be necessary for doing a preclass work, meaning higher priority, but it does not matter whether you eat lunch or go to a cafe first if you just want to do your preclass work. In this case, we say that eating lunch has more priority than going to a cafe because it brings more happiness and future usefulness. (If you are interested, you can go to utility section to see how we actually determine!)
After sorting non-fixed-time tasks that have to precede fixed-time task, we start creating your schedule. We start from top-priority non-fixed time task. We check if the top-priority task overlaps with starting time of top priority fixed-time task, and if not, we put the non-fixed-time task into our schedule. If it does, it means that we should do fixed time task (as you cannot change the time of the task) first. Each time you put the task into schedule, you eliminate the task from the list, so that the next top-priority task will be the top priority task.
We continue step 4, until either there is no task in the non-fixed task list or fixed-task list.
If the non-fixed task list becomes empty first, we begin prioritizing the remaining non-fixed time tasks. Like step 3, we first sort by dependency: If task A precedes task B, task A has more priority. Same a task 3, if two tasks happen to have same priority based on this criteria, we decide which one to do first based on the happiness and future usefulness a task brings to you.
If the fixed task list becomes empty first, this means that tasks that should precede fixed-time tasks are not properly scheduled, it means that our scheduling failed.
After step 6, we go back to the step 4, and start adding non-fixed task based on the priority. Each time, we check if the ending time passes the end of day; if so, we will suggest you to skip the task and do it tomorrow, and continue with scheduling each task, until there is no more task left unscheduled

The output:
Schedule of all of your tasks and expected time of completion (or if all the tasks cannot be finished in a day, identify tasks that cannot be finished on the day.)

## Utility function

Our priority value represents how urgent it is to complete the task, meaning that the task with the maximized priority value has the highest urgency. Therefore we use max-heap so that when we execute HEAP-EXTRACT-MAX, we can always extract the most urgent task in the heap and restore the heap property.
As we have two priority queues for fixed-time task and non-fixed time task, we apply two different utility functions.
“Fixed-time”: When tasks have a fixed starting time, the utility function is defined as follows: Priority value = 1440 -t, where t is an integer from 0 to 1439 that represents the minutes of the day (e.g. 3 PM is 60*15 = 900). This is because when we compare fixed-time tasks A and B, task A has higher urgency and thus a higher priority value if task A starts earlier than task B. The utility function above reflects that, and we add 1 to t to make sure that we do not divide by zero when it is 0 AM. Also, as 1 <= t+1 <= 1440, it means that the range of possible priority value is 1 <= priority value <= 1440.
“Non-fixed-time”: When tasks have a non-fixed starting time, we have to consider the fixed-time tasks’ dependency on non-fixed-time tasks. For instance, if fixed-time tasks A and B have a dependency on non-fixed-time tasks C and D respectively, where A has a higher priority value than B (which means that A starts earlier than B,) we reasonably assign a higher priority value to C than D because finishing task C is more urgent than D. To reflect this feature, we first iterative goes through the dependency lists of fixed-time tasks, and as we find non-fixed time tasks assign priority value = 1440 - t + 1/len(all_tasks) to each non-fixed time tasks. If multiple values are assigned, we take higher values.  (This way you can correctly update non-fixed time priority if it appears on multiple dependencies of fixed-time tasks). Next, we need to update the priority value of non-fixed tasks that precedes non-fixed tasks that fixed-time tasks are dependent on to ensure that the former has a higher priority than the latter, ensuring that the former is performed first. Here, we have to be careful about the values we add when we find such dependencies. For instance, if tasks A, and B are fixed-time tasks in the right priority order, and each has a dependency on non-fixed-time tasks C and D, we start by assigning the priority value of B and A to D and C (and plus 1/len(all_tasks)) respectively. Then we look for dependencies in C and D, where we find that D is dependent on non-fixed time task E, so we have to assign a priority value to E that is higher than D. However, it should not be higher than the priority value of task C because task E is still in the dependencies chain of B which has less priority values than A. As the smallest priority value difference in a fixed-time task is 1, and a non-fixed time task can be the consequence of up to n -1 number of updates where n is the number of non-fixed tasks (e.g.  A->B->C->D->E, where E can be the result of updating of these four arrows), the addition should be 1/len(n) where n is the number of all tasks to maintain the property.
Also, I would use happiness, future usefulness to calculate the priority value. This is to be used when non-fixed-time task A and non-fixed-time task B has same priority value based on dependency, we decide the priority based on happiness and future usefulness. Otherwise, dependency should be the deciding factor, so this second utility function’s value should be kept small.  Happiness and usefulness are described in a scale of 1 to 5 where 5 is very happy/ very useful. Here we define the priority value as follows: Priority value = ((H-3)+2*(F-3)/ (12*len(all_tasks)+1), where H is the happiness level, F is future usefulness and D is time duration in minutes. First, we subtract 3 from H and F to make 0 as representing neutral stance for both. Then, we do 2*(F-3) to give more weights to future usefulness. With this expression, I want to not just include instant happiness you get from tasks, but also future usefulness we tend to underestimate.
"""

class MaxHeapq:
    """
    A class that implements properties and methods
    that support a max priority queue data structure

    Attributes
    ----------
    heap : arr
    A Python list where key values in the max heap are stored
    heap_size: int
          An integer counter of the number of keys present in the max heap
    """

    def __init__(self):
        """
        Parameters
        ----------
        None
        """
        self.heap       = []
        self.heap_size  = 0

    def left(self, i):
        """
        Takes the index of the parent node
        and returns the index of the left child node

        Parameters
        ----------
        i: int
          Index of parent node

        Returns
        ----------
        int
          Index of the left child node
        """
        return 2 * i + 1

    def right(self, i):
        """
        Takes the index of the parent node
        and returns the index of the right child node

        Parameters
        ----------
        i: int
            Index of parent node

        Returns
        ----------
        int
            Index of the right child node
        """
        return 2 * i + 2

    def parent(self, i):
        """
        Takes the index of the child node
        and returns the index of the parent node

        Parameters
        ----------
        i: int
            Index of child node

        Returns
        ----------
        int
            Index of the parent node
        """

        return (i - 1)//2

    def maxk(self):
        """
       Returns the task object with the highest utility value in the priority queue.
        Parameters
        ----------
        None

        Returns
        ----------
        int
            a task object with the highest utility in the priority queue
        """
        # Check if the heap is not empty
        if self.heap:
            return self.heap[0][0]
        #Return None if the heap is empty
        else:
            return None

    def heappush(self, task_tuple):
        """
        Insert a task into the max heap.

        Parameters
        ----------
        task: tuple of (Task object, utility of the Task)

        Returns
        ----------
        None
        """

        task, key = task_tuple
        self.heap.append((task,key))  # Append the correct value directly
        self.heap_size += 1
        self.increase_key(self.heap_size - 1, key)

    def increase_key(self, i, key):
        """
        Modifies the value of a key in a max priority queue
        with a higher value

        Parameters
        ----------
        i: int
            The index of the key to be modified
        key: int
            The new key value

        Returns
        ----------
        None
        """
        if key < self.heap[i][1]:
            raise ValueError('new key is smaller than the current key')
        self.heap[i] = (self.heap[i][0], key)
        while i > 0 and self.heap[self.parent(i)][1] < self.heap[i][1]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)

    def decrease_key(self, i, key):
        """
        Modifies the value of a key in a max priority queue
        with a smaler value

        Parameters
        ----------
        i: int
            The index of the key to be modified
        key: int
            The new key value

        Returns
        ----------
        None
        """
        if key > self.heap[i][1]:
            raise ValueError('new key is larger than the current key')
        self.heap[i] = (self.heap[i][0], key)
        self.heapify(i)

    def heapify(self, i):
        """
        Creates a max heap from the index given

        Parameters
        ----------
        i: int
            The index of of the root node of the subtree to be heapify

        Returns
        ----------
        None
        """
        l = self.left(i)
        r = self.right(i)
        heap = self.heap
        if l <= (self.heap_size-1) and heap[l][1]>heap[i][1]:
            largest = l
        else:
            largest = i
        if r <= (self.heap_size-1) and heap[r][1] > heap[largest][1]:
            largest = r
        if largest != i:
            heap[i], heap[largest] = heap[largest], heap[i]
            self.heapify(largest)

    def heappop(self):
        """
        returns the larest tuple(task, task_utility) in the max priority queue
        and remove it from the max priority queue

        Parameters
        ----------
        None

        Returns
        ----------
        int
            the max value in the heap that is extracted
        """
        if self.heap_size < 1:
            raise ValueError('Heap underflow: There are no keys in the priority queue')
        max_item = self.heap[0]
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        self.heap_size-=1
        self.heapify(0)
        return max_item

# Define a tentative task that returns the utility as its own value for test cases.
class Testcase:
    def __init__(self, value):
        self.value = value

    def utility(self):
        return self.value
#These four test cases check if the methods in MaxHeapq class works as intended using assert statement.
#It also checks if the methods successfully raise error message if the heap is empty

# Test case 1: Insert elements and remove the max
heapq1 = MaxHeapq()
# Push a Task object
for i in range(10):
    task = Testcase(i)
    task_tuple = (task, task.utility())
    heapq1.heappush(task_tuple)
for i in range(10):
    # Check that popping is correctly implemented
    max_task = heapq1.heappop()

# Test case 2: Increase and decrease keys
heapq2 = MaxHeapq()
for i in range(10):
    task = Testcase(i)
    task_tuple = (task, task.utility())
    heapq2.heappush(task_tuple)
heapq2.increase_key(3, 30)
assert heapq2.heap[0][1] == 30
heapq2.decrease_key(0, -1)
assert heapq2.heap[0][1] == 9

# Test case 3: Build heap
heapq3 = MaxHeapq()
unsorted_array = [Testcase(i) for i in [4,7,8,0,3,2,5,1,6]]
# Create a heap of tuples
heapq3.heap = [(i,i.utility()) for i in unsorted_array]
heapq3.heap_size = len(unsorted_array)
for i in range(int(heapq3.heap_size/2), -1, -1):
    heapq3.heapify(i)
assert heapq3.heappop()[1] == 8  # Compare with the utility value

# Test case 4: Error handling
heapq4 = MaxHeapq()
try:
    heapq4.heappop()  # This should raise an error
except ValueError as e:
    assert str(e) == 'Heap underflow: There are no keys in the priority queue' # The expected error message

try:
    heapq4.increase_key(0, 5)  # This should raise an error
except IndexError as e:
    assert 'list index out of range' in str(e)  # The expected error message

"""B. Program an active scheduler using OOP"""

class TaskDurationAverageTracker:
    """
    Keeps track of task duration associated with specific ID if the task is a regular task that has no fixed duration.

    Attributes
    ----------
    durations : dictionary
        A dictionary to store total duration and count for each task ID. {'duration', 'count'}
    """
    def __init__(self):
        self.durations = {}

    def add_duration(self, task_id, duration):
        """
        Updates the duration and count of a specific task associated with ID.
        Parameters
        ----------
        - task_id：int
            ID of the task.
        - duration: int
            Total duration of the task

        Returns
        ----------
        None
        """
        if task_id not in self.durations:
            self.durations[task_id] = {'total': 0, 'count': 0}

        self.durations[task_id]['total'] += duration
        self.durations[task_id]['count'] += 1

    def get_average_duration(self, task_id):
        """
        Updates the duration and count of a specific task associated with ID.
        Parameters
        ----------
        - task_id：int
            ID of the task.

        Returns
        ----------
        - :average_duration: float
            average duration of the task
        None
        """
        if task_id not in self.durations or self.durations[task_id]['count'] == 0:
            # No duration recorded for this task ID
            return None

        total_duration = self.durations[task_id]['total']
        count = self.durations[task_id]['count']
        average_duration = total_duration / count
        return average_duration

class Task:
    """
    Represents a task with various attributes including its priority calculation.

    Attributes
    ----------
    id : int
        Task id (a reference number).
    description : str
        Short description of each task.
    fixed_start_time : int
        If the task has a fixed starting time, write the time (if it is 4 PM, write as 1600).
        If not, write -1.
    fixed_duration : bool
        Indicates if the task has a fixed duration.
    regular_task : bool
        Indicates if the task is a routine task.
    duration : int
        Task duration in minutes.
    dependencies : list
        List of task ids that is a prerequisite for this task.
    happiness : int
        Happiness level from completing the task (1 to 5, 5 being very happpy).
    future_usefulness : int
        Future usefulness of the task (1 to 5, 5 being very useful).
    status : str
        Current status of the task; 'N' for not started, 'I' for in priority queue, 'C' for completed.
    priority : float
        priority value of the task.
    duration_tracker: instance
        instance of class TaskDurationAverageTracker
    """

    def __init__(self, id, description, fixed_duration, regular_task, duration, dependencies, happiness, future_usefulness, fixed_start_time=-1, status='N', priority=0, duration_tracker = None):
        self.id = id
        self.description = description
        self.fixed_start_time = fixed_start_time
        self.fixed_duration = fixed_duration
        self.regular_task = regular_task
        self.duration = duration
        self.dependencies = dependencies
        self.happiness = happiness
        self.future_usefulness = future_usefulness
        self.status = status
        self.priority = priority
        self.duration_tracker = duration_tracker if duration_tracker else TaskDurationAverageTracker()

    def priority_fixed_time(self):
        """
        Calculate the priority value of the task that has a fixed time.

        Returns
        -------
        float
            The calculated priority value.
        """
        #convert input to a proper form that can be computed
        if self.fixed_start_time != -1:
            hours = int(self.fixed_start_time / 100)
            minutes = self.fixed_start_time % 100
            time_in_minutes = hours * 60 + minutes
            priority_value = 1440 - time_in_minutes
            return priority_value
        return None

    def priority_non_dependency(self, total_tasks):
        """
        Calculate the priority value of the task based on happiness, future usefulness,
        and the total number of tasks.

        Parameters
        ----------
        total_tasks : int
            The total number of tasks in the task scheduler.

        Returns
        -------
        float
            The calculated priority value.
        """
        #if input is invalid, raise an error.
        if not (1 <= self.happiness <= 5):
            raise ValueError("Happiness must be between 1 and 5")
        if not (1 <= self.future_usefulness <= 5):
            raise ValueError("Future usefulness must be between 1 and 5")
        priority_value = ((self.happiness-3) + 2*(self.future_usefulness-3)) / (12* total_tasks+1)

        return priority_value

    def convert_to_minutes(self):
        """
        Convert fixed start time to minutes past midnight.

        Returns
        -------
        int
            Time in minutes past midnight.
        """
        hours = int(self.fixed_start_time / 100)
        minutes = self.fixed_start_time % 100
        return hours * 60 + minutes

    def get_average_duration(self):
        """
        Gets the average duration for this task from the duration tracker.

        Returns
        -------
        float or None
            The average duration if available, otherwise None.
        """
        if self.regular_task and not self.fixed_duration:
            avg_duration = self.duration_tracker.get_average_duration(self.id)
            return avg_duration
        return None

    def update_duration_to_average(self):
        """
        Updates the task's duration to the average duration.
        """
        avg_duration = self.get_average_duration()
        if avg_duration is not None:
            self.duration = avg_duration

    def update_duration(self, actual_duration):
        """
        Updates the task's duration with the actual duration after you completed the task.

        Parameters
        ----------
        actual_duration : float
            The actual duration to update the task with.
        """
        self.duration = actual_duration
        if self.regular_task and not self.fixed_duration:
            self.duration_tracker.add_duration(self.id, actual_duration)

class TaskScheduler:
    """
    A task scheduler based on calculated priority.
    We have two priority queues for fixed_start_time task and non_fixed_start_time task.

    Attributes
    ----------
    tasks : list
        A list of Tasks.
    fixed_time_priority_queue : MaxHeapq
        Priority queue (max heap) for tasks with fixed start time.
    non_fixed_time_priority_queue : MaxHeapq
        Priority queue (max heap) for tasks with non_fixed start time.
    """
    NOT_STARTED = 'N'
    IN_PRIORITY_QUEUE = 'I'
    COMPLETED = 'C'

    def __init__(self, tasks):
        self.tasks = tasks
        self.fixed_time_priority_queue = MaxHeapq()
        self.non_fixed_time_priority_queue = MaxHeapq()

    def print_self(self):
        """
        Prints all tasks with their description and duration.
        """
        print("Tasks added to the simple scheduler:")
        print("--------------------------------------")
        if not self.tasks:
            print("You have no task to do. Enjoy your day!")
        else:
            for task in self.tasks:
                print(f"➡️ '{task.description}', duration = {task.duration} minutes.")

    def remove_dependency(self, id):
        """
        Remove the ID of a completed task from other tasks' dependency lists.

        Parameters
        ----------
        - ID：int
            ID of the task.

        Returns
        ----------
        None
        """
        for task in self.tasks:
            if id in task.dependencies:
                task.dependencies.remove(id)

    def get_fixed_tasks_ready(self):
        """
        Prepare tasks with fixed_start_time for scheduling by adding them to the fixed-time priority queue.
        """
        for task in self.tasks:
            #check if the task is not started and the task has a fixed start time
            if task.status == self.NOT_STARTED and task.fixed_start_time != -1:
                #push into priority queue based on priority value for fixed time task
                task.status = self.IN_PRIORITY_QUEUE
                self.fixed_time_priority_queue.heappush((task, task.priority_fixed_time()))


    def update_task_priorities_from_fixed_task(self):
        """
        Update the priority of all tasks with a fixed start time's dependencies.

        Parameters
        ----------
        None
        """

        for task in self.tasks:
            if task.fixed_start_time != -1:
                priority_value = task.priority_fixed_time()
                # Only update if the new priority is higher than the original
                if task.priority < priority_value:
                    task.priority = priority_value
                self.recursively_add_priority(task.id, priority_value)

    def recursively_add_priority(self, task_id, priority_value, visited=None):
        """
        Recursively add priority to a task's dependencies.

        Parameters
        ----------
        task_id : int
            The ID of the task to update the priority for.
        priority_value : float
            The priority value of the task that is dependent on the task with task_id.
        visited : set
            A set of task IDs that have been visited to avoid infinite recursion.
        """
        if visited is None:
            visited = set()

        task = self.get_task_by_id(task_id)
        #if a task is not visited yet, add it to the set
        if task and task_id not in visited:
            visited.add(task_id)
            # Only update if the new priority is higher
            if task.priority < priority_value:
                task.priority = priority_value
            # Calculate priority addition based on the total number of tasks
            priority_addition = 1 / len(self.tasks)
            # Recursively update the priority of the dependencies
            for dependency_id in task.dependencies:
                self.recursively_add_priority(dependency_id, priority_value + priority_addition, visited)

    def get_task_by_id(self, task_id):
        """
        Retrieve a task by its ID.
        """
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None



    def get_nonfixed_tasks_ready(self):
        """
        Add non-fixed-time tasks that should precede fixed-time tasks into a priority queue
        based on priority value. Priority value is based on mixture of dependency and non-dependency priority,
        where more weights are given to the prior
        """
        for task in self.tasks:
            #task.priority != 0 checks if the non-fixed-time priority is updated with update_task_priorities_from_fixed_task()
            if task.status == self.NOT_STARTED and task.fixed_start_time == -1 and task.priority != 0:
                task.status = self.IN_PRIORITY_QUEUE
                #combine dependency priority and non-dependency priority
                #adding non-dependency priority helps us to decide order when two tasks have exactly same value based on dependency priority
                task.priority += task.priority_non_dependency(len(self.tasks))
                self.non_fixed_time_priority_queue.heappush((task, task.priority))

    def get_tasks_ready(self):
        """
        Push non-fixed tasks that fixed_time are not directly or indirectly dependent on.
        This will be executed after get_non_fixed_tasks_ready
        ----------
        None
        """
        for task in self.tasks:
            if task.status == self.NOT_STARTED and not task.dependencies:
                task.status = self.IN_PRIORITY_QUEUE
                self.non_fixed_time_priority_queue.heappush((task,task.priority_non_dependency(len(self.tasks))))

    def check_unscheduled_tasks(self):
        """
        Check whether there are still tasks that are not put into priority queues.

        Parameters
        ----------
        None

        Returns
        ----------
        - True： if there are still undone tasks
        - False: if there are no undone tasks
        """
        for task in self.tasks:
            if task.status == self.NOT_STARTED:
                return True
        return False

    def format_time(self, time):
        """
        Format a time value in minutes past midnight to clock's format.

        Parameters
        ----------
        - time：int
            time past midnight in minutes.

        Returns
        ----------
        - str
            A formatted time string in hours and minutes.
        """
        return f"{time // 60} hours {time % 60:02d} minutes"

    def run_task_scheduler(self, starting_time):
        """
        Executes the task scheduling process from a given starting time.

        Parameters
        ----------
        starting_time : int
            The starting time in minutes past midnight from which scheduling begins.

        Returns
        ----------
        - tasks_schedule: list
            A Python list with the IDs of tasks in the order of schedule.
        """
        #count how many tasks are unfinished at the end of day
        unfinished = 0
        current_time = starting_time
        print("Running a simple scheduler:\n")
        tasks_schedule = []

        #push all fixed_time tasks into a priority queue for fixed time task
        self.get_fixed_tasks_ready()
        #recursively update non_fixed_time tasks that fixed_time tasks are dependent on
        self.update_task_priorities_from_fixed_task()
        #push the updated non_fixed_time tasks into the priority queue for non_fixed_time task
        self.get_nonfixed_tasks_ready()


        while self.fixed_time_priority_queue.heap_size>0:
            #case1: when there are tasks in both queues
            if self.non_fixed_time_priority_queue.heap_size>0:
                non_fixed_time_task = self.non_fixed_time_priority_queue.maxk()
                fixed_time_task = self.fixed_time_priority_queue.maxk()
                #case1-1: when the root task in the non_fixed_time task queues does not overlap with the root task in the fixed_time task
                #pop the non_fixed_time task from the priority queue and print it
                if current_time + non_fixed_time_task.duration <= fixed_time_task.convert_to_minutes():
                    task = non_fixed_time_task
                    self.non_fixed_time_priority_queue.heappop()
                    print(f"🕰 Time = {self.format_time(current_time)}")
                    print(f"\t🙌 Started '{task.description}' for {task.duration} minutes...")
                    print(f"\t🌟 Task priority = {task.priority}")
                    current_time += task.duration
                    print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")
                #case1-2: when the root task in the non_fixed_time task queues overlaps with the root task in the fixed_time task
                #pop the fixed_time task from the priority queue and print it
                else:
                    task = fixed_time_task
                    self.fixed_time_priority_queue.heappop()
                    print(f"🕰 Time = {self.format_time(task.convert_to_minutes())}")
                    print(f"\t🙌 Started '{task.description}' for {task.duration} minutes...")
                    print(f"\t🌟 Task priority = {task.priority}")
                    current_time = task.convert_to_minutes() + task.duration
                    print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")

                #remove the removed task from the dependency list of remaining tasks
                self.remove_dependency(task.id)
                task.status = self.COMPLETED
                tasks_schedule.append(task.id)

            #case2: after all the non_fixed_time tasks that fixed time tasks are dependent on are scheduled, push the remaining tasks that have no dependencies into priority queue
            else:
                #case2-1: after push, there are tasks in both queues. (non_fixed_time_task is not empty after push)
                self.get_tasks_ready()
                if self.non_fixed_time_priority_queue.heap_size>0:
                    non_fixed_time_task = self.non_fixed_time_priority_queue.maxk()
                    fixed_time_task = self.fixed_time_priority_queue.maxk()
                    #case2-1-1: when the root task in the non_fixed_time task queues does not overlap with the root task in the fixed_time task
                    if current_time + non_fixed_time_task.duration <= fixed_time_task.convert_to_minutes():
                        task = non_fixed_time_task
                        self.non_fixed_time_priority_queue.heappop()
                        print(f"🕰 Time = {self.format_time(current_time)}")
                        print(f"\t🙌 Started '{task.description}' for {task.duration} minutes...")
                        print(f"\t🌟 Task priority = {task.priority}")
                        current_time += task.duration
                        print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")
                    #case2-1-2: when the root task in the non_fixed_time task queues overlaps with the root task in the fixed_time task
                    else:
                        task = fixed_time_task
                        self.fixed_time_priority_queue.heappop()
                        print(f"🕰 Time = {self.format_time(task.convert_to_minutes())}")
                        print(f"\t🙌 Started '{task.description}' for {task.duration} minutes...")
                        print(f"\t🌟 Task priority = {task.priority}")
                        current_time = task.convert_to_minutes() + task.duration
                        print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")

                #case2-2 after push,non_fixed_time_task is still empty but there are tasks in fixed_time task priority queue
                else:
                    task = self.fixed_time_priority_queue.heappop()[0]
                    print(f"🕰 Time = {self.format_time(task.convert_to_minutes())}")
                    print(f"\t🙌 Started '{task.description}' for {task.duration} minutes...")
                    print(f"\t🌟 Task priority = {task.priority}")
                    current_time = task.convert_to_minutes() + task.duration
                    print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")

                self.remove_dependency(task.id)
                task.status = self.COMPLETED
                tasks_schedule.append(task.id)

        #case3: when there are no tasks in the fixed-time priority queue, but there are some tasks left in the non_fixed_time priority queue
        self.get_tasks_ready()

        while self.non_fixed_time_priority_queue.heap_size>0:
            self.get_tasks_ready()
            task = self.non_fixed_time_priority_queue.heappop()[0]
            current_time += task.duration
            #check if, after completing the non-fixed-time task, it overlaps with the next day
            if current_time <= 1440:
                current_time -= task.duration
                print(f"🕰 Time = {self.format_time(current_time)}")
                print(f"\t🙌 started '{task.description}' for {task.duration} mins...")
                print(f"\t🌟 Task priority = {task.priority}")
                current_time += task.duration
                print(f"\t✅ Time = {self.format_time(current_time)}, task completed!")

            #if it overlaps, print that the task cannot be finished today, and keep track of the number of tasks that cannot be finished
            else:
                unfinished +=1
                print(f"🕰 Time = {self.format_time(current_time)}")
                print(f"\t🙌 started '{task.description}'...")
                print(f"\t😥 task cannot be finished today... but you can try tomorrow!")
                current_time -= task.duration
            self.remove_dependency(task.id)
            task.status = self.COMPLETED
            tasks_schedule.append(task.id)



        total_time = current_time - starting_time
        #check if all the tasks are finished in the day
        if unfinished == 0:
            print(f"\n🏁 Completed all planned tasks in {total_time // 60} hours {total_time % 60:02d} minutes!")
        else:
             print(f"\n🏁 Completed some of the planned tasks in {total_time // 60} hours {total_time % 60:02d} minutes! still have {unfinished} number of tasks, but you can surely finish by tomorrow!")
        return tasks_schedule

"""## test case 1-1: Order of tasks by ID"""

duration_tracker = TaskDurationAverageTracker()
tasks =[
    Task(id=0, description="Prepare for CS 110 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=90, dependencies=[7, 4], happiness=4, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=1, description="Prepare for AH 111 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=60, dependencies=[7, 4], happiness=3, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=2, description="Review CS 110 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[5], happiness=4, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=3, description="Review AH 111 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[6], happiness=3, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=4, description="Go to Sookmyung Women’s University Library to study", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=30, dependencies=[], happiness=5, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=5, description="Take CS 110 class", fixed_start_time=1800, fixed_duration=True, regular_task=True, duration=90, dependencies=[0], happiness=5, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=6, description="Take AH 111 class", fixed_start_time=2100, fixed_duration=True, regular_task=True, duration=90, dependencies=[1], happiness=4, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=7, description="Eat lunch at Sookmyung Women’s University", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=30, dependencies=[4], happiness=5, future_usefulness=2, duration_tracker=duration_tracker),
    Task(id=8, description="Eat dinner at a local restaurant", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=50, dependencies=[7], happiness=5, future_usefulness=2, duration_tracker=duration_tracker),
    Task(id=9, description="Go running with friends", fixed_start_time=1000, fixed_duration=True, regular_task=False, duration=30, dependencies=[], happiness=2, future_usefulness=4, duration_tracker=duration_tracker)
]
#adding the tasks into the TaskScheduler
task_scheduler = TaskScheduler(tasks)
#print the tasks in the task scheduler
task_scheduler.print_self()

#time started from 9 a.m.
start_scheduler_at = 9*60
#run the task scheduler
task_schedule = task_scheduler.run_task_scheduler(start_scheduler_at)

"""## test case 1-2: Randomized order of tasks"""

#test cases 1: Randomized order of tasks

import random

#creating tasks manually (data same as test case 1)
randomized_tasks =[
    Task(id=0, description="Prepare for CS 110 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=90, dependencies=[7, 4], happiness=4, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=1, description="Prepare for AH 111 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=60, dependencies=[7, 4], happiness=3, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=2, description="Review CS 110 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[5], happiness=4, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=3, description="Review AH 111 class", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[6], happiness=3, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=4, description="Go to Sookmyung Women’s University Library to study", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=30, dependencies=[], happiness=5, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=5, description="Take CS 110 class", fixed_start_time=1800, fixed_duration=True, regular_task=True, duration=90, dependencies=[0], happiness=5, future_usefulness=5, duration_tracker=duration_tracker),
    Task(id=6, description="Take AH 111 class", fixed_start_time=2100, fixed_duration=True, regular_task=True, duration=90, dependencies=[1], happiness=4, future_usefulness=4, duration_tracker=duration_tracker),
    Task(id=7, description="Eat lunch at Sookmyung Women’s University", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=30, dependencies=[4], happiness=5, future_usefulness=2, duration_tracker=duration_tracker),
    Task(id=8, description="Eat dinner at a local restaurant", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=50, dependencies=[7], happiness=5, future_usefulness=2, duration_tracker=duration_tracker),
    Task(id=9, description="Go running with friends", fixed_start_time=1000, fixed_duration=True, regular_task=False, duration=30, dependencies=[], happiness=2, future_usefulness=4, duration_tracker=duration_tracker)
]

#shuffle the order of tasks
random.shuffle(randomized_tasks)

randomized_task_scheduler = TaskScheduler(randomized_tasks)

#print the tasks (not scheduled yet)
randomized_task_scheduler.print_self()

#time started from 9 a.m.
start_scheduler_at = 9*60

#schedule the task
randomized_task_schedule = randomized_task_scheduler.run_task_scheduler(start_scheduler_at)

#check if input by ID and randomized input produce a same schedule
assert task_schedule == randomized_task_schedule

"""## test case 2: when there is no task"""

empty_tasks = [ ]

empty_task_scheduler = TaskScheduler(empty_tasks)
#print the tasks (not scheduled yet)
empty_task_scheduler.print_self()

#time starts from 9 a.m.
start_scheduler_at = 9*60

#schedule tasks (no task)
empty_task_schedule = empty_task_scheduler.run_task_scheduler(start_scheduler_at)

"""## test case 3: Update the time duration of regular, non-fixed-duration tasks based on the average"""

task = tasks[0]  # Get a first task from the scheduler

#initial expectation of duration of CS preparation 90 min
initial_duration = task.duration

#update the value of duration with actual duraiton
task.update_duration(60)
#expect 60
task.update_duration_to_average()
updated_duration = task.duration
#update the value of duration with actual duraiton for the second time
task.update_duration(90)
#now expect 75 as (60+90)/2 = 75
task.update_duration_to_average()
second_updated_duration = task.duration

print('initial duration is' , initial_duration, "first updated duration is" , updated_duration, "second updated duration is" , second_updated_duration)

"""## test case 4-1 : simple test case"""

#define simple tasks
simple_tasks= [
    Task(id=0, description="task0", fixed_start_time=1000, fixed_duration=False, regular_task=True, duration=90, dependencies=[2], happiness=4, future_usefulness=5),
    Task(id=1, description="task1", fixed_start_time=1800, fixed_duration=False, regular_task=True, duration=60, dependencies=[3], happiness=3, future_usefulness=4),
    Task(id=2, description="task2", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[], happiness=4, future_usefulness=5),
    Task(id=3, description="task3", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[], happiness=3, future_usefulness=5),
    Task(id=4, description="task4", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=30, dependencies=[5], happiness=5, future_usefulness=4),
    Task(id=5, description="task5", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=90, dependencies=[], happiness=5, future_usefulness=5),
    Task(id=6, description="task6", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=90, dependencies=[5], happiness=5, future_usefulness=5),
    Task(id=7, description="task7", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=800, dependencies=[], happiness=2, future_usefulness=2),
]

simple_task_scheduler = TaskScheduler(simple_tasks)
#print the tasks (not sorted yet)
simple_task_scheduler.print_self()

#time starts from 9 a.m.
start_scheduler_at = 9*60

#schedule tasks
simple_task_scheduler = simple_task_scheduler.run_task_scheduler(start_scheduler_at)

"""## test case 4-2: Simple test case with randomized order of input"""

#define simple tasks
randomized_simple_tasks= [
    Task(id=0, description="task0", fixed_start_time=1000, fixed_duration=False, regular_task=True, duration=90, dependencies=[2], happiness=4, future_usefulness=5),
    Task(id=1, description="task1", fixed_start_time=1800, fixed_duration=False, regular_task=True, duration=60, dependencies=[3], happiness=3, future_usefulness=4),
    Task(id=2, description="task2", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[], happiness=4, future_usefulness=5),
    Task(id=3, description="task3", fixed_start_time=-1, fixed_duration=False, regular_task=True, duration=20, dependencies=[], happiness=3, future_usefulness=5),
    Task(id=4, description="task4", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=30, dependencies=[5], happiness=5, future_usefulness=4),
    Task(id=5, description="task5", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=90, dependencies=[], happiness=5, future_usefulness=5),
    Task(id=6, description="task6", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=90, dependencies=[5], happiness=5, future_usefulness=5),
    Task(id=7, description="task7", fixed_start_time=-1, fixed_duration=True, regular_task=True, duration=800, dependencies=[], happiness=2, future_usefulness=2),
]

#shuffle the order of tasks
random.shuffle(randomized_simple_tasks)

randomized_simple_task_scheduler = TaskScheduler(randomized_simple_tasks)

#print the tasks (not scheduled yet)
randomized_simple_task_scheduler.print_self()

#time starts from 9 a.m.
start_scheduler_at = 9*60

#schedule tasks
randomized_simple_task_scheduler = randomized_simple_task_scheduler.run_task_scheduler(start_scheduler_at)

#check if input by ID and randomized input produce a same schedule
assert(simple_task_scheduler == randomized_simple_task_scheduler)

"""Explanation for simple tasks:
We start by calculating the priority_value for fixed time tasks "task0" and "task 1". (priority_fixed_time())
"task 0" = 1440 - 600 = 840.
"task 1" = 1440 - 1080 = 360.

As all the priority value for fixed_tasks are calculated, we push them to the self.fixed_priority_queue (= "task0", "task1")

Then, we iterate through the dependencies of task 0 and task 1. (update_task_priorities_from_fixed_task())
task0's dependency = [2] -> "task2"'s priority value = 840+ len(self.tasks) = 840+ 1/8
task1's dependency = [3] -> "task3"'s priority value = 360+ len(self.tasks) = 360+ 1/8

As both task0 and task 1 have no dependency, we stop the recursion here.

Then, we add priority_based on happiness and usefulness to task 0 and task 1 (it will be useful if task0 and task1 had same priority based on dependencies),
and we push these tasks into the self.non_fixed_priority_queue(= "task2" "task3")

Next, we start printing the schedule run_task_scheduler(). we first, extract the root of self.non_fixed_priority_queue(= "task2") and check if the time overlaps with
the root of self.fixed_priority_queue(= "task0") as 09:00 + 20 <= 10:00, we pop task2, print it, and remove the task from the dependencies of other tasks. (We call it process A)

We repeat this process, until either queue is emptied. In this case, task2 and task3 successfully fits before the task0, so the self.non_fixed_priority_queue is emptied.

As self.non_fixed_priority_queue is emptied, we start comparing non_fixed_time tasks that are still not pushed into the priority queue. We first take the tasks that have no dependencies
(get_tasks_ready()), which is task 5 and task 7. Then, we compare their utilities that are basd on happiness and usefulness, and since task 5 has higher priority , we push both into self.non_fixed_priority_queue(= "task5" "task7")

Here, we do the process A, and find that task 5 overlaps with task0, a fixed task. Therefore, we schedule task first, and then check if task5 overlaps with task1, which does not. So we schedule task 5 next. Next, we check if task 7 overlaps with task 1, which does so print out task 1 and remove it from the dependencies list of other tasks.

As all the fixed time tasks are executed, we then push tasks without dependencies to self.non_fixed_priority_queue, which is task7, task6, and task4, as task 5 is eliminated from the dependencies list. (self.get_tasks_ready()) We compare the priority values, and push them into the priority queue(= task6, task4, task7).

Then, we pop the root element of the non_fixed_time queue, but each time we pop we check if the end_time of task exceedes the end of day. We check with task6 and task 4, and both ends before the end of the day (20:30 and 21:00). Then we check if task7 ends before the end of the day, and it does not as 21:00 + 800 > 24:00, therefore we mark it as unfinished task, and print it as the tasks you can do tomorrow. In the end, it prints the time it took to complete all the tasks you complete (except task 7.)

The benefit of algorithm:
Priority is strictly determined by dependencies: As mentioned in my formulation of utility function, utility is strictly determined by the dependencies and then the second priority function based on usefulness and happiness. This makes the most sense, because if task A is dependent on B, task B must be given higher priority than A. Priority function based on usefulness and happiness should only play a role if two tasks have two priority.
Dynamic update of duration: My code dyamically updates the time duration based on past average duration. This helps error-prone human being to better estimate time duration.

My code can be extended even more. For instance, my algorithm does not take into account time gap between each task, which is difficult to achieve with heap sort strucuture. We can utilize this by integrating spaced learning o #sceienceoflearning, which is something that I could not achieve here.
"""